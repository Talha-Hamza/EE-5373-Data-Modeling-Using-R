C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^3 + Z^2+ Z + C
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
# Based on https://en.wikipedia.org/wiki/R_%28programming_language%29
##########################################################
# Define the fractal function
fractal <- function(iters, dim, xlo, xhi, ylo, yhi) {
C <- complex( real=rep(seq(xlo,xhi, length.out=dim), each=dim ),
imag=rep(seq(ylo,yhi, length.out=dim), dim ) )
C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^5 + Z^4+ Z^3 + Z^2+ Z + C
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
# Based on https://en.wikipedia.org/wiki/R_%28programming_language%29
##########################################################
# Define the fractal function
fractal <- function(iters, dim, xlo, xhi, ylo, yhi) {
C <- complex( real=rep(seq(xlo,xhi, length.out=dim), each=dim ),
imag=rep(seq(ylo,yhi, length.out=dim), dim ) )
C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^5 + Z^4+ Z^3 + Z^2+ C
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
# Based on https://en.wikipedia.org/wiki/R_%28programming_language%29
##########################################################
# Define the fractal function
fractal <- function(iters, dim, xlo, xhi, ylo, yhi) {
C <- complex( real=rep(seq(xlo,xhi, length.out=dim), each=dim ),
imag=rep(seq(ylo,yhi, length.out=dim), dim ) )
C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^9+Z^8+Z^7+Z^6+Z^5 + Z^4+ Z^3 + Z^2+ Z + C
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
# Based on https://en.wikipedia.org/wiki/R_%28programming_language%29
##########################################################
# Define the fractal function
fractal <- function(iters, dim, xlo, xhi, ylo, yhi) {
C <- complex( real=rep(seq(xlo,xhi, length.out=dim), each=dim ),
imag=rep(seq(ylo,yhi, length.out=dim), dim ) )
C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^8+Z^7+Z^6+Z^5 + Z^4+ Z^3 + Z^2+ Z + C
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
Z <- Z^7+Z^6+Z^5 + Z^4+ Z^3 + Z^2+ Z + C
# Based on https://en.wikipedia.org/wiki/R_%28programming_language%29
##########################################################
# Define the fractal function
fractal <- function(iters, dim, xlo, xhi, ylo, yhi) {
C <- complex( real=rep(seq(xlo,xhi, length.out=dim), each=dim ),
imag=rep(seq(ylo,yhi, length.out=dim), dim ) )
C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^7+Z^6+Z^5 + Z^4+ Z^3 + Z^2+ Z + C
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
# Based on https://en.wikipedia.org/wiki/R_%28programming_language%29
##########################################################
# Define the fractal function
fractal <- function(iters, dim, xlo, xhi, ylo, yhi) {
C <- complex( real=rep(seq(xlo,xhi, length.out=dim), each=dim ),
imag=rep(seq(ylo,yhi, length.out=dim), dim ) )
C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^6+Z^5 + Z^4+ Z^3 + Z^2+ Z + C
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
# Based on https://en.wikipedia.org/wiki/R_%28programming_language%29
##########################################################
# Define the fractal function
fractal <- function(iters, dim, xlo, xhi, ylo, yhi) {
C <- complex( real=rep(seq(xlo,xhi, length.out=dim), each=dim ),
imag=rep(seq(ylo,yhi, length.out=dim), dim ) )
C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^5 + Z^4+ Z^3 + Z^2+ Z + C
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
Z <- Z^3 + Z^2+C
# Based on https://en.wikipedia.org/wiki/R_%28programming_language%29
##########################################################
# Define the fractal function
fractal <- function(iters, dim, xlo, xhi, ylo, yhi) {
C <- complex( real=rep(seq(xlo,xhi, length.out=dim), each=dim ),
imag=rep(seq(ylo,yhi, length.out=dim), dim ) )
C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^3 + Z^2+C
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
# Based on https://en.wikipedia.org/wiki/R_%28programming_language%29
##########################################################
# Define the fractal function
fractal <- function(iters, dim, xlo, xhi, ylo, yhi) {
C <- complex( real=rep(seq(xlo,xhi, length.out=dim), each=dim ),
imag=rep(seq(ylo,yhi, length.out=dim), dim ) )
C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^5+Z^4+Z^3+Z^2+C
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
# Based on https://en.wikipedia.org/wiki/R_%28programming_language%29
##########################################################
# Define the fractal function
fractal <- function(iters, dim, xlo, xhi, ylo, yhi) {
C <- complex( real=rep(seq(xlo,xhi, length.out=dim), each=dim ),
imag=rep(seq(ylo,yhi, length.out=dim), dim ) )
C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^6+Z^5+Z^4+Z^3+Z^2+ZC
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
# Based on https://en.wikipedia.org/wiki/R_%28programming_language%29
##########################################################
# Define the fractal function
fractal <- function(iters, dim, xlo, xhi, ylo, yhi) {
C <- complex( real=rep(seq(xlo,xhi, length.out=dim), each=dim ),
imag=rep(seq(ylo,yhi, length.out=dim), dim ) )
C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^6+Z^5+Z^4+Z^3+Z^2+Z+C
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
# Based on https://en.wikipedia.org/wiki/R_%28programming_language%29
##########################################################
# Define the fractal function
fractal <- function(iters, dim, xlo, xhi, ylo, yhi) {
C <- complex( real=rep(seq(xlo,xhi, length.out=dim), each=dim ),
imag=rep(seq(ylo,yhi, length.out=dim), dim ) )
C <- array(C,c(dim,dim)) # reshape as square matrix of complex numbers
Z <- 0
for (k in 1:iters) {
Z <- Z^7+Z^6+Z^5+Z^4+Z^3+Z^2+Z+C
}
X <- array(0, c(dim,dim))
X <- exp(-abs(Z))
image(X,col=heat.colors(100))
}
##########################################################
##########################################################
# The main program starts here.
#
fractal(iters=20, dim=500, xlo=-1.8, xhi=0.6, ylo=-1.2, yhi=1.2)
# Exercise 2:
# Read in the data (update the path as needed)
cereal <- read.csv(file.choose(), header = TRUE)
View(cereal)
# a. Use either names() or head( ) to identify the names of all four variables
#    Determine if variables are quantitative or qualitative.
names(cereal)
head(cereal)
str(cereal$Sugar)
str(cereal$Sodium)
str(cereal$Cereal)
str(cereal$Type)
# b. Use nrow() or tail() to determine the number of observations in the cereal dataset.
nrow(cereal)
# c. Use table() to create a summary table of Type (C for children / A for Adult's cereal).
#    Identify the number of children cereals and adult's cereals in the data set.
table(cereal$Type)
boxplot(cereal$Sugar, ylab = "Amount of Sugar (g)",
main = "Boxplot of Cereal Sugar")
hist(cereal$Sugar, ylab = "Amount of Sugar (g)",
main = "Histogram of Cereal Sugar")
boxplot(cereal$Sugar ~ Type)
boxplot(cereal$Sugar ~ cereal$Type)
# f. Use summary() command to find the five number summary of sugar amount.
#    Does the results agree with the boxplot from part d? Compute the IQR.
#    Again, does this agree with the boxplot from part d?
summary(cereal$Sugar)
IQR <- 12.50 - 4
IQR
# g. Find the mean and standard deviation of sugar content. Are the mean and median close?
mean(cereal$Sugar)
median(cereal$Sugar)
hist(cereal$Sugar, ylab = "Amount of Sugar (g)",
main = "Histogram of Cereal Sugar")
hist(cereal$Sugar, ylab = "Amount of Sugar (g)",
main = "Histogram of Cereal Sugar", breaks = 10)
# read the data
peaks <- read.csv(file.shoose(), header = TRUE)
# read the data
peaks <- read.csv(file.choose(), header = TRUE)
# read the data
peaks <- read.csv(file.choose(), header = TRUE)
hist(peaks$Ascent, ylab = "Count", main = "Histogram of Ascent")
head(peaks)
boxplot(peaks$Elevation ~ peaks$Ascent)
boxplot(peaks$Elevation ~ peaks$Peak)
boxplot(peaks$Difficulty ~ peaks$Length)
boxplot(peaks$Length ~ peaks$Difficulty)
# a
hist(peaks$Ascent, ylab = "Count", main = "Histogram of Ascent")
peaks <- read.csv(file.choose(), header = TRUE)
head(peaks)
hist(peaks$Ascent)
hist(peaks$Elevation)
IQR(peaks$Elevation)
summary(peaks$Elevation)
IQR <- 4625 - 4105
IQR
boxplot(peaks$Length ~ peaks$Difficulty)
set1 <- c(8, 9 , 10 , 11, 12)
median(set1)
setwd("~/UMN-EE-coursework/Fall 2025/EE 5373/lab2")
clear
# Read the data from the csv file.
processors <- read.csv("all-data.csv")
# Functions to read in the CSV table that contains all of the raw data.
# Before running these functions, make sure the file "all-data.csv" is
# in the local directory.
# Also, within the R environment, change the working directory to the directory
# that contains the data file using the toolbar menu:
# File -> Change dir
#
# Read the data from the csv file.
processors <- read.csv("all-data.csv")
################################################################
#
# This function returns the data from the desired column.
# Example:  clock<-get_column("Fp2000","Processor.Clock..MHz.")
get_column <- function(x,y) {
# x = string with the name of the desired benchmark
# y = desired column
#
# Find the indices of all rows that have an entry for the
# indicated benchmark
benchmark <- paste(paste("Spec",x,sep=""),"..average.base.",
sep="")
ix <- !is.na(processors[,benchmark])
return(processors[ix,y])
}
################################################################
################################################################
# This function extracts the interesting data columns for the given benchmark
# program and returns a dataframe with these columns.
extract_data <- function(benchmark) {
temp <- paste(paste("Spec",benchmark,sep=""),"..average.base.", sep="")
# perf = the performance reported in the database
perf <- get_column(benchmark,temp)
#nperf = performance normalized to the overall range
max_perf <- max(perf)
min_perf <- min(perf)
range <- max_perf - min_perf
nperf <- 100 * (perf - min_perf) / range
clock <- get_column(benchmark,"Processor.Clock..MHz.")
threads <- get_column(benchmark,"Threads.core")
cores <- get_column(benchmark,"Cores")
TDP <- get_column(benchmark,"TDP")
transistors <- get_column(benchmark,"Transistors..millions.")
dieSize <- get_column(benchmark,"Die.size..mm.2.")
voltage <- get_column(benchmark,"Voltage..low.")
featureSize <- get_column(benchmark,"Feature.Size..microns.")
channel <- get_column(benchmark,"Channel.length..microns.")
FO4delay <- get_column(benchmark,"FO4.Delay..ps.")
L1icache <- get_column(benchmark,"L1..instruction...on.chip.")
L1dcache <- get_column(benchmark,"L1..data...on.chip.")
L2cache <- get_column(benchmark,"L2..on.chip.")
L3cache <- get_column(benchmark,"L3..on.chip.")
return(data.frame(nperf,perf,clock,threads,cores,TDP,transistors,dieSize,voltage,featureSize,channel,FO4delay,L1icache,L1dcache,L2cache,L3cache))
}
################################################################
# Extract a new data frame for each of the benchmark programs available in the data set.
int92.dat <- extract_data("Int1992")
fp92.dat <- extract_data("Fp1992")
int95.dat <- extract_data("Int1995")
fp95.dat <- extract_data("Fp1995")
int00.dat <- extract_data("Int2000")
fp00.dat <- extract_data("Fp2000")
int06.dat <- extract_data("Int2006")
fp06.dat <- extract_data("Fp2006")
cleat
mean(int92.dat)
mean(int92.dat, rm.na = TRUE)
mean(int92.dat, na.rm = TRUE)
mean(fp92.dat, na.rm = TRUE)
head(int92.dat)
head(fp92.dat)
View(fp92.dat)
head(int95.dat)
fp06.dat(int95.dat)
head(fp06.dat)
boxplot(fp06.dat$nperf)
boxplot(fp06.dat$perf)
boxplot(fp06.dat$clock)
boxplot(fp06.dat$threads)
boxplot(fp06.dat$threads)
boxplot(fp06.dat$cores)
boxplot(fp06.dat$TDP)
boxplot(fp06.dat$transistors)
boxplot(fp06.dat$transistors)
boxplot(fp06.dat$dieSize)
boxplot(fp06.dat$voltage)
boxplot(fp06.dat$featureSize)
boxplot(fp06.dat$channel)
boxplot(fp06.dat$FO4delay)
boxplot(fp06.dat$L1icache)
boxplot(fp06.dat$L2cache)
boxplot(fp06.dat$L3cache)
boxplot(fp06.dat$nperf, main = "Boxplot of nperf")
boxplot(fp06.dat$perf, main = "Boxplot of perf")
boxplot(fp06.dat$clock, main = "Boxplot of clock")
boxplot(fp06.dat$threads, main = "Boxplot of threads")
boxplot(fp06.dat$cores, main = "Boxplot of cores")
boxplot(fp06.dat$TDP, main = "Boxplot of TDP")
boxplot(fp06.dat$transistors, main = "Boxplot of transistors")
boxplot(fp06.dat$dieSize, main = "Boxplot of dieSize")
boxplot(fp06.dat$voltage, main = "Boxplot of voltage")
boxplot(fp06.dat$featureSize, main = "Boxplot of featureSize")
boxplot(fp06.dat$channel, main = "Boxplot of channel")
boxplot(fp06.dat$FO4delay, main = "Boxplot of FO4delay")
boxplot(fp06.dat$L1icache, main = "Boxplot of L1icache")
boxplot(fp06.dat$L2cache, main = "Boxplot of L2cache")
boxplot(fp06.dat$L3cache, main = "Boxplot of L3cache")
mean(fp06.dat$nperf)
max(fp06.dat$nperf)
min(fp06.dat$nperf)
mean(fp06.dat$perf) # 35.97, no NA values
max(fp06.dat$perf) # clean 100
min(fp06.dat$perf)
mean(fp06.dat$clock)
max(fp06.dat$clock)
min(fp06.dat$clock)
table(fp06.dat$threads)
table(fp06.dat$clock)
table(fp06.dat$threads)
table(fp06.dat$transistors)
mean(fp06.dat$transistors)
mean(fp06.dat$transistors, na.rm = table)
mean(fp06.dat$transistors, na.rm = TRUE)
mean(fp06.dat$featureSize, na.rm = TRUE)
min(fp06.dat$featureSize)
max(fp06.dat$featureSize)
median(fp06.dat$featureSize)
mean(fp06.dat$featureSize, na.rm = TRUE)
median(fp06.dat$featureSize)
min(fp06.dat$featureSize)
max(fp06.dat$featureSize)
sd(fp06.dat$featureSize)
0.13-0.05
0.08/0.016
table(fp06.dat$channel)
table(fp06.dat$FO4delay)
mean(fp06.dat$FO4delay)
median(fp06.dat$FO4delay)
sd(fp06.dat$FO4delay)
max(fp06.dat$FO4delay)
min(fp06.dat$FO4delay)
table(fp06.dat$L1icache)
table(fp06.dat$L2cache)
na_count_col1 <- sum(is.na(fp06.dat$transistors))
na_count_col1 <- sum(is.na(fp06.dat$L3cache))
na_count_col1
head(fp06.dat$L3cache)
nrows(fp06.dat$L3cache)
nrows(fp06.dat)
nrow(fp06.dat)
nrow(fp06.dat$L3cache)
nrow(fp06.dat$L3cace)
nrows(fp06.dat)
nrow(fp06.dat$L3cace)
nrow(fp06.dat)
sum(is.na(fp06.dat$L3cache))
124/193
na_count_col1 <- sum(is.na(fp06.dat$L3cache))
total <- nrow(fp06.dat)
ratio <- na_count_col1 / total
ratio
na_count_col1 <- sum(is.na(fp06.dat$L2cache))
total <- nrow(fp06.dat)
ratio <- na_count_col1 / total
ratio
na_count_col1 <- sum(is.na(fp06.dat$L1dcache))
total <- nrow(fp06.dat)
ratio <- na_count_col1 / total
ratio
na_count_col1 <- sum(is.na(fp06.dat$L1icache))
total <- nrow(fp06.dat)
ratio <- na_count_col1 / total
ratio
na_count_col1 <- sum(is.na(fp06.dat$channel))
total <- nrow(fp06.dat)
ratio <- na_count_col1 / total
ratio
na_ratio <- function(x) {
# Check if the input is not a vector or is empty
if (!is.vector(x) || length(x) == 0) {
return(NA) # Return NA if the input is not valid
}
na_count <- sum(is.na(x))
total_count <- length(x)
if (total_count == 0) {
return(0) # Avoid division by zero
}
return(na_count / total_count)
}
# Apply the na_ratio function to all columns of fp06.dat
na_ratios_all <- sapply(fp06.dat, na_ratio)
print(na_ratios_all)
